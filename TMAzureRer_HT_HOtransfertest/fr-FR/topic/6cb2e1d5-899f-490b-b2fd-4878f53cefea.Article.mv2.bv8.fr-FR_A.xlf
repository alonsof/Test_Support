<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <file datatype="xml" source-language="en-US" target-language="fr-FR" original="file.ddue" tool-id="caps" product-name="n/a" product-version="n/a" build-num="n/a">
    <header>
      <tool tool-id="caps" tool-name="CAPS" tool-version="2.0" tool-company="Microsoft">
        <xliffext:info xsi:schemaLocation="urn:microsoft:content:schema:xliffextensions xliffext-xliffextension.xsd" xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
          <xliffext:uhg>oQAAAB+LCAAAAAAABAANy8sJwzAMANBVNIAE/siJ3QFKz6ULyLIEgTaBNIWM39zfc8/WOSmZMRNHD9RD7aQhytSaR5GGkKdZWUOlokGJU/NLjUY1lc7SImcZCJP2ZHEUqlckbqFTTz6I61y9ZDU3QYgIvtP9iXC+F3c7j9u+bQdCQqgIj99H1tcu6/ctx7KtfyBE6iihAAAA</xliffext:uhg>
        </xliffext:info>
      </tool>
    </header>
    <body>
      <group extype="metadata">
        <group id="1">
          <trans-unit id="1" translate="yes" xml:space="preserve">
            <source>JOIN</source>
            <target state="new">JOIN</target>
            <context-group>
              <context context-type="x-metadataname">toc_title</context>
            </context-group>
          </trans-unit>
        </group>
        <group id="2">
          <trans-unit id="2" translate="yes" xml:space="preserve">
            <source>JOIN (Azure Stream Analytics)</source>
            <target state="new">JOIN (Azure Stream Analytics)</target>
            <context-group>
              <context context-type="x-metadataname">name</context>
            </context-group>
          </trans-unit>
        </group>
      </group>
      <group extype="content">
        <group id="3">
          <trans-unit id="3" translate="yes" xml:space="preserve">
            <source>Like standard T-SQL, JOIN in the Azure Stream Analytics query language are used to combine records from two or more input sources.</source>
            <target state="new">Like standard T-SQL, JOIN in the Azure Stream Analytics query language are used to combine records from two or more input sources.</target>
          </trans-unit>
          <trans-unit id="4" translate="yes" xml:space="preserve">
            <source>JOIN in Azure Stream Analytics are temporal in nature, meaning that each JOIN must provide some limits on how far the matching rows can be separated in time.</source>
            <target state="new">JOIN in Azure Stream Analytics are temporal in nature, meaning that each JOIN must provide some limits on how far the matching rows can be separated in time.</target>
          </trans-unit>
          <trans-unit id="5" translate="yes" xml:space="preserve">
            <source>For instance, saying “join TollBoothEntry events with TollBoothExit events when they occur on the same LicensePlate and TollId and within 5 minutes of each other” is legitimate; but “join TollBoothEntry events with TollBoothExit events when they occur on the LicensePlate and TollId” is not – it would match each TollBoothEntry with an unbounded and potentially infinite collection of all TollBoothExit to the same LicensePlate and TollId.</source>
            <target state="new">For instance, saying “join TollBoothEntry events with TollBoothExit events when they occur on the same LicensePlate and TollId and within 5 minutes of each other” is legitimate; but “join TollBoothEntry events with TollBoothExit events when they occur on the LicensePlate and TollId” is not – it would match each TollBoothEntry with an unbounded and potentially infinite collection of all TollBoothExit to the same LicensePlate and TollId.</target>
          </trans-unit>
        </group>
        <group id="4">
          <trans-unit id="6" translate="yes" xml:space="preserve">
            <source>The time bounds for the relationship are specified inside the ON clause of the JOIN, using the DATEDIFF function.</source>
            <target state="new">The time bounds for the relationship are specified inside the ON clause of the JOIN, using the DATEDIFF function.</target>
          </trans-unit>
          <trans-unit id="7" translate="yes" xml:space="preserve">
            <source>For more details on its general use, see <ph id="1">&lt;link xlink:href="e8f6ec67-f286-4fa5-8acf-ae7c179d8b19" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;DATEDIFF (Azure Stream Analytics)&lt;/link&gt;</ph>.</source>
            <target state="new">For more details on its general use, see <ph id="1">&lt;link xlink:href="e8f6ec67-f286-4fa5-8acf-ae7c179d8b19" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;DATEDIFF (Azure Stream Analytics)&lt;/link&gt;</ph>.</target>
          </trans-unit>
          <trans-unit id="8" translate="yes" xml:space="preserve">
            <source>When DATEDIFF is used inside the JOIN condition, the second and third parameter gain special treatment.</source>
            <target state="new">When DATEDIFF is used inside the JOIN condition, the second and third parameter gain special treatment.</target>
          </trans-unit>
        </group>
        <group id="5">
          <trans-unit id="9" translate="yes" xml:space="preserve">
            <source>Syntax</source>
            <target state="new">Syntax</target>
          </trans-unit>
        </group>
        <group id="6">
          <trans-unit id="10" translate="yes" xml:space="preserve">
            <source>Arguments</source>
            <target state="new">Arguments</target>
          </trans-unit>
        </group>
        <group id="7">
          <trans-unit id="11" translate="yes" xml:space="preserve">
            <source>&lt;input_source&gt; </source>
            <target state="new">&lt;input_source&gt; </target>
          </trans-unit>
        </group>
        <group id="8">
          <trans-unit id="12" translate="yes" xml:space="preserve">
            <source>Specifies the input data source.</source>
            <target state="new">Specifies the input data source.</target>
          </trans-unit>
        </group>
        <group id="9">
          <trans-unit id="13" translate="yes" xml:space="preserve">
            <source>&lt;reference_data&gt; </source>
            <target state="new">&lt;reference_data&gt; </target>
          </trans-unit>
        </group>
        <group id="10">
          <trans-unit id="14" translate="yes" xml:space="preserve">
            <source>The reference data to which you want to Join your input_source.</source>
            <target state="new">The reference data to which you want to Join your input_source.</target>
          </trans-unit>
          <trans-unit id="15" translate="yes" xml:space="preserve">
            <source>For more information, see Reference Data Join section.</source>
            <target state="new">For more information, see Reference Data Join section.</target>
          </trans-unit>
        </group>
        <group id="11">
          <trans-unit id="16" translate="yes" xml:space="preserve">
            <source>&lt;join_type&gt; </source>
            <target state="new">&lt;join_type&gt; </target>
          </trans-unit>
        </group>
        <group id="12">
          <trans-unit id="17" translate="yes" xml:space="preserve">
            <source>Specifies the type of join operation.</source>
            <target state="new">Specifies the type of join operation.</target>
          </trans-unit>
        </group>
        <group id="13">
          <trans-unit id="18" translate="yes" xml:space="preserve">
            <source>JOIN</source>
            <target state="new">JOIN</target>
          </trans-unit>
        </group>
        <group id="14">
          <trans-unit id="19" translate="yes" xml:space="preserve">
            <source>Indicates that the specified join operation should occur between the specified input sources and /or reference data.</source>
            <target state="new">Indicates that the specified join operation should occur between the specified input sources and /or reference data.</target>
          </trans-unit>
          <trans-unit id="20" translate="yes" xml:space="preserve">
            <source>All rows from the left and right meeting the join condition are included in the result set.</source>
            <target state="new">All rows from the left and right meeting the join condition are included in the result set.</target>
          </trans-unit>
        </group>
        <group id="15">
          <trans-unit id="21" translate="yes" xml:space="preserve">
            <source>NOTE:If JOIN sources are partitioned, the JOIN predicate must include a condition matching the partition keys of both sources.</source>
            <target state="new">NOTE:If JOIN sources are partitioned, the JOIN predicate must include a condition matching the partition keys of both sources.</target>
          </trans-unit>
        </group>
        <group id="16">
          <trans-unit id="22" translate="yes" xml:space="preserve">
            <source>[ LEFT  OUTER JOIN ] </source>
            <target state="new">[ LEFT  OUTER JOIN ] </target>
          </trans-unit>
        </group>
        <group id="17">
          <trans-unit id="23" translate="yes" xml:space="preserve">
            <source>Specifies that all rows from the left table not meeting the join condition are included in the result set, and output columns from the other table are set to NULL in addition to all rows returned by the inner join.</source>
            <target state="new">Specifies that all rows from the left table not meeting the join condition are included in the result set, and output columns from the other table are set to NULL in addition to all rows returned by the inner join.</target>
          </trans-unit>
        </group>
        <group id="18">
          <trans-unit id="24" translate="yes" xml:space="preserve">
            <source>ON &lt;join_condition&gt;</source>
            <target state="new">ON &lt;join_condition&gt;</target>
          </trans-unit>
        </group>
        <group id="19">
          <trans-unit id="25" translate="yes" xml:space="preserve">
            <source>Specifies the condition on which the join is based.</source>
            <target state="new">Specifies the condition on which the join is based.</target>
          </trans-unit>
          <trans-unit id="26" translate="yes" xml:space="preserve">
            <source>The join condition must have a time bound or a temporal wiggle room defined for the relationship and is specified inside the ON clause of the JOIN, using the special syntax of <ph id="1">&lt;link xlink:href="6cb2e1d5-899f-490b-b2fd-4878f53cefea#BKMK_DateDiff" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;Special DATEDIFF Function for JOIN&lt;/link&gt;</ph>function.</source>
            <target state="new">The join condition must have a time bound or a temporal wiggle room defined for the relationship and is specified inside the ON clause of the JOIN, using the special syntax of <ph id="1">&lt;link xlink:href="6cb2e1d5-899f-490b-b2fd-4878f53cefea#BKMK_DateDiff" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;Special DATEDIFF Function for JOIN&lt;/link&gt;</ph>function.</target>
          </trans-unit>
        </group>
        <group id="20">
          <trans-unit id="27" translate="yes" xml:space="preserve">
            <source>Examples</source>
            <target state="new">Examples</target>
          </trans-unit>
        </group>
        <group id="21">
          <trans-unit id="28" translate="yes" xml:space="preserve">
            <source>In Azure Stream Analytics, all events have a well-defined timestamp.</source>
            <target state="new">In Azure Stream Analytics, all events have a well-defined timestamp.</target>
          </trans-unit>
          <trans-unit id="29" translate="yes" xml:space="preserve">
            <source>Thus, the user must use row aliases directly in the DATEDIFF function, as follows:</source>
            <target state="new">Thus, the user must use row aliases directly in the DATEDIFF function, as follows:</target>
          </trans-unit>
        </group>
        <group id="22">
          <trans-unit id="30" translate="yes" xml:space="preserve">
            <source>The join condition above will result in a match if and only if the ExitTime occurs after the EntryTime, but no more than 15 minutes later.</source>
            <target state="new">The join condition above will result in a match if and only if the ExitTime occurs after the EntryTime, but no more than 15 minutes later.</target>
          </trans-unit>
        </group>
        <group id="23">
          <trans-unit id="31" translate="yes" xml:space="preserve">
            <source>DATEDIFF used in the SELECT statement uses the general syntax where we pass a datetime column or expression as the second and third parameter.</source>
            <target state="new">DATEDIFF used in the SELECT statement uses the general syntax where we pass a datetime column or expression as the second and third parameter.</target>
          </trans-unit>
          <trans-unit id="32" translate="yes" xml:space="preserve">
            <source>But when we use the DATEDIFF function inside the JOIN condition, we pass the input_source name or its alias.</source>
            <target state="new">But when we use the DATEDIFF function inside the JOIN condition, we pass the input_source name or its alias.</target>
          </trans-unit>
          <trans-unit id="33" translate="yes" xml:space="preserve">
            <source>Internally the timestamp associated for each event in that source is picked.</source>
            <target state="new">Internally the timestamp associated for each event in that source is picked.</target>
          </trans-unit>
        </group>
        <group id="24">
          <trans-unit id="34" translate="yes" xml:space="preserve">
            <source>You cannot use SELECT * in JOIN.</source>
            <target state="new">You cannot use SELECT * in JOIN.</target>
          </trans-unit>
        </group>
        <group id="25">
          <trans-unit id="35" translate="yes" xml:space="preserve">
            <source>Time bound conditions can be combined with each other and with other conditions inside the ON clause, e.g.:</source>
            <target state="new">Time bound conditions can be combined with each other and with other conditions inside the ON clause, e.g.:</target>
          </trans-unit>
        </group>
        <group id="26">
          <trans-unit id="36" translate="yes" xml:space="preserve">
            <source>When joining 3 or more tables, the same rules apply --- time bounds must ensure that all matched events occur within a finite amount of time from each other.</source>
            <target state="new">When joining 3 or more tables, the same rules apply --- time bounds must ensure that all matched events occur within a finite amount of time from each other.</target>
          </trans-unit>
          <trans-unit id="37" translate="yes" xml:space="preserve">
            <source>For instance, to find all errors that occurred between transaction start and transaction end event, one can say:</source>
            <target state="new">For instance, to find all errors that occurred between transaction start and transaction end event, one can say:</target>
          </trans-unit>
        </group>
        <group id="27">
          <trans-unit id="38" translate="yes" xml:space="preserve">
            <source>When joining sources that are partitioned, the JOIN predicate must include a condition matching the partition keys of both sources.</source>
            <target state="new">When joining sources that are partitioned, the JOIN predicate must include a condition matching the partition keys of both sources.</target>
          </trans-unit>
        </group>
        <group id="28">
          <trans-unit id="39" translate="yes" xml:space="preserve">
            <source>Finally, Azure Stream Analytics supports both inner join (the default) and LEFT outer join.</source>
            <target state="new">Finally, Azure Stream Analytics supports both inner join (the default) and LEFT outer join.</target>
          </trans-unit>
          <trans-unit id="40" translate="yes" xml:space="preserve">
            <source>For an inner join, a result is only returned when a match is found.</source>
            <target state="new">For an inner join, a result is only returned when a match is found.</target>
          </trans-unit>
          <trans-unit id="41" translate="yes" xml:space="preserve">
            <source>But for a LEFT OUTER join, if an event from the left side of the join is unmatched, a row with NULL for all the columns of the right row is returned.</source>
            <target state="new">But for a LEFT OUTER join, if an event from the left side of the join is unmatched, a row with NULL for all the columns of the right row is returned.</target>
          </trans-unit>
          <trans-unit id="42" translate="yes" xml:space="preserve">
            <source>For instance here is an example to find the absence of events.</source>
            <target state="new">For instance here is an example to find the absence of events.</target>
          </trans-unit>
          <trans-unit id="43" translate="yes" xml:space="preserve">
            <source>The following query will return those rows where a Vehicle has entered a Toll Booth but have not exited the Booth within 15 minutes.</source>
            <target state="new">The following query will return those rows where a Vehicle has entered a Toll Booth but have not exited the Booth within 15 minutes.</target>
          </trans-unit>
        </group>
        <group id="29">
          <trans-unit id="44" translate="yes" xml:space="preserve">
            <source>Special DATEDIFF Function for JOIN</source>
            <target state="new">Special DATEDIFF Function for JOIN</target>
          </trans-unit>
        </group>
        <group id="30">
          <trans-unit id="45" translate="yes" xml:space="preserve">
            <source>Syntax</source>
            <target state="new">Syntax</target>
          </trans-unit>
        </group>
        <group id="31">
          <trans-unit id="46" translate="yes" xml:space="preserve">
            <source>Arguments</source>
            <target state="new">Arguments</target>
          </trans-unit>
        </group>
        <group id="32">
          <trans-unit id="47" translate="yes" xml:space="preserve">
            <source>dateparts </source>
            <target state="new">dateparts </target>
          </trans-unit>
        </group>
        <group id="33">
          <trans-unit id="48" translate="yes" xml:space="preserve">
            <source>Example.</source>
            <target state="new">Example.</target>
          </trans-unit>
          <trans-unit id="49" translate="yes" xml:space="preserve">
            <source>‘second’, ‘millisecond’, ‘minute’, etc)</source>
            <target state="new">‘second’, ‘millisecond’, ‘minute’, etc)</target>
          </trans-unit>
        </group>
        <group id="34">
          <trans-unit id="50" translate="yes" xml:space="preserve">
            <source>input_source1</source>
            <target state="new">input_source1</target>
          </trans-unit>
        </group>
        <group id="35">
          <trans-unit id="51" translate="yes" xml:space="preserve">
            <source>The first input source in the Join.</source>
            <target state="new">The first input source in the Join.</target>
          </trans-unit>
          <trans-unit id="52" translate="yes" xml:space="preserve">
            <source>Internally the timestamp associated with the events from this input_source is passed into the function.</source>
            <target state="new">Internally the timestamp associated with the events from this input_source is passed into the function.</target>
          </trans-unit>
        </group>
        <group id="36">
          <trans-unit id="53" translate="yes" xml:space="preserve">
            <source>input_source2</source>
            <target state="new">input_source2</target>
          </trans-unit>
        </group>
        <group id="37">
          <trans-unit id="54" translate="yes" xml:space="preserve">
            <source>The second input source in the Join.</source>
            <target state="new">The second input source in the Join.</target>
          </trans-unit>
          <trans-unit id="55" translate="yes" xml:space="preserve">
            <source>Internally the timestamp associated with the events from this input_source is passed into the function.</source>
            <target state="new">Internally the timestamp associated with the events from this input_source is passed into the function.</target>
          </trans-unit>
        </group>
        <group id="38">
          <trans-unit id="56" translate="yes" xml:space="preserve">
            <source>Return Type</source>
            <target state="new">Return Type</target>
          </trans-unit>
        </group>
        <group id="39">
          <trans-unit id="57" translate="yes" xml:space="preserve">
            <source>Returns the number of units in dateparts that elapsed from the timestamp of input_source1 to the timestamp of input_source2.</source>
            <target state="new">Returns the number of units in dateparts that elapsed from the timestamp of input_source1 to the timestamp of input_source2.</target>
          </trans-unit>
          <trans-unit id="58" translate="yes" xml:space="preserve">
            <source>Note that the returned value can be negative if the timestamp of second input_source is greater than the first.</source>
            <target state="new">Note that the returned value can be negative if the timestamp of second input_source is greater than the first.</target>
          </trans-unit>
        </group>
        <group id="40">
          <trans-unit id="59" translate="yes" xml:space="preserve">
            <source>The maximum size of the window in all cases is 7 days.</source>
            <target state="new">The maximum size of the window in all cases is 7 days.</target>
          </trans-unit>
        </group>
      </group>
    </body>
  </file>
</xliff>