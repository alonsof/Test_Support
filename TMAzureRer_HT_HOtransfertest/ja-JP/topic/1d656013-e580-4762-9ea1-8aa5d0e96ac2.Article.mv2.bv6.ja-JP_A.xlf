<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <file datatype="xml" source-language="en-US" target-language="ja-JP" original="file.ddue" tool-id="caps" product-name="n/a" product-version="n/a" build-num="n/a">
    <header>
      <tool tool-id="caps" tool-name="CAPS" tool-version="2.0" tool-company="Microsoft">
        <xliffext:info xsi:schemaLocation="urn:microsoft:content:schema:xliffextensions xliffext-xliffextension.xsd" xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
          <xliffext:uhg>oQAAAB+LCAAAAAAABAANzVEKwjAMgOGr9AANJG0aW08gPvngBdIugcncQCfs+O75/+B3z9Y5DTBjBiZH6Fg7DCSV1pxUWwypn1m4QGUi4FEHNDGHnjvSKFkllxhokiJIGaxUBL5IgmZKUFXLhNZERzpVDC+F+yOGY5nd7divn23bz0kMEsPt99b1+dH1u+g+b+sfgohcSaEAAAA=</xliffext:uhg>
        </xliffext:info>
      </tool>
    </header>
    <body>
      <group extype="metadata">
        <group id="1">
          <trans-unit id="1" translate="yes" xml:space="preserve">
            <source>Simple query syntax</source>
            <target state="new">Simple query syntax</target>
            <context-group>
              <context context-type="x-metadataname">toc_title</context>
            </context-group>
          </trans-unit>
        </group>
        <group id="2">
          <trans-unit id="2" translate="yes" xml:space="preserve">
            <source>Simple query syntax in Azure Search</source>
            <target state="new">Simple query syntax in Azure Search</target>
            <context-group>
              <context context-type="x-metadataname">name</context>
            </context-group>
          </trans-unit>
        </group>
      </group>
      <group extype="content">
        <group id="3">
          <trans-unit id="3" translate="yes" xml:space="preserve">
            <source>Azure Search uses a simple query syntax for search text.</source>
            <target state="new">Azure Search uses a simple query syntax for search text.</target>
          </trans-unit>
          <trans-unit id="4" translate="yes" xml:space="preserve">
            <source>This syntax is designed to be end-user friendly and is processed in a way that is tolerant to errors.</source>
            <target state="new">This syntax is designed to be end-user friendly and is processed in a way that is tolerant to errors.</target>
          </trans-unit>
        </group>
        <group id="4">
          <trans-unit id="5" translate="yes" xml:space="preserve">
            <source>As a starting point, any text with one or more terms is a valid query.</source>
            <target state="new">As a starting point, any text with one or more terms is a valid query.</target>
          </trans-unit>
          <trans-unit id="6" translate="yes" xml:space="preserve">
            <source>Depending on the <ph id="1">&lt;languageKeyword&gt;searchMode&lt;/languageKeyword&gt;</ph> parameter, <bpt id="2">&lt;legacyLink xlink:href="716ef056-adf4-4b16-85b8-2cb777bc8458" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;</bpt>search<ept id="2">&lt;/legacyLink&gt;</ept> will match documents containing any or all of the terms, including any variations found during analysis of the text.</source>
            <target state="new">Depending on the <ph id="1">&lt;languageKeyword&gt;searchMode&lt;/languageKeyword&gt;</ph> parameter, <bpt id="2">&lt;legacyLink xlink:href="716ef056-adf4-4b16-85b8-2cb777bc8458" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;</bpt>search<ept id="2">&lt;/legacyLink&gt;</ept> will match documents containing any or all of the terms, including any variations found during analysis of the text.</target>
          </trans-unit>
        </group>
        <group id="5">
          <trans-unit id="7" translate="yes" xml:space="preserve">
            <source>Search operators</source>
            <target state="new">Search operators</target>
          </trans-unit>
        </group>
        <group id="6">
          <trans-unit id="8" translate="yes" xml:space="preserve">
            <source>Additionally, the following characters may be used to fine-tune the query:</source>
            <target state="new">Additionally, the following characters may be used to fine-tune the query:</target>
          </trans-unit>
        </group>
        <group id="7">
          <trans-unit id="9" translate="yes" xml:space="preserve">
            <source>AND operator.</source>
            <target state="new">AND operator.</target>
          </trans-unit>
          <trans-unit id="10" translate="yes" xml:space="preserve">
            <source>For example, "wifi+luxury" will search for documents containing both "wifi" and "luxury".</source>
            <target state="new">For example, "wifi+luxury" will search for documents containing both "wifi" and "luxury".</target>
          </trans-unit>
        </group>
        <group id="8">
          <trans-unit id="11" translate="yes" xml:space="preserve">
            <source>OR operator.</source>
            <target state="new">OR operator.</target>
          </trans-unit>
          <trans-unit id="12" translate="yes" xml:space="preserve">
            <source>For example, "wifi|luxury" will search for documents containing either "wifi" or "luxury" or both.</source>
            <target state="new">For example, "wifi|luxury" will search for documents containing either "wifi" or "luxury" or both.</target>
          </trans-unit>
        </group>
        <group id="9">
          <trans-unit id="13" translate="yes" xml:space="preserve">
            <source>NOT operator.</source>
            <target state="new">NOT operator.</target>
          </trans-unit>
          <trans-unit id="14" translate="yes" xml:space="preserve">
            <source>For example, "wifi –luxury" will search for documents that have the "wifi" term and/or do not have "luxury" (and/or is controlled by <ph id="1">&lt;languageKeyword&gt;searchMode&lt;/languageKeyword&gt;</ph>).</source>
            <target state="new">For example, "wifi –luxury" will search for documents that have the "wifi" term and/or do not have "luxury" (and/or is controlled by <ph id="1">&lt;languageKeyword&gt;searchMode&lt;/languageKeyword&gt;</ph>).</target>
          </trans-unit>
        </group>
        <group id="10">
          <trans-unit id="15" translate="yes" xml:space="preserve">
            <source>The <ph id="1">&lt;languageKeyword&gt;searchMode&lt;/languageKeyword&gt;</ph> option controls whether a term with the NOT operator is ANDed or ORed with the other terms in the query in the absence of a <ph id="2">&lt;languageKeyword&gt;+&lt;/languageKeyword&gt;</ph> or <ph id="3">&lt;languageKeyword&gt;|&lt;/languageKeyword&gt;</ph> operator.</source>
            <target state="new">The <ph id="1">&lt;languageKeyword&gt;searchMode&lt;/languageKeyword&gt;</ph> option controls whether a term with the NOT operator is ANDed or ORed with the other terms in the query in the absence of a <ph id="2">&lt;languageKeyword&gt;+&lt;/languageKeyword&gt;</ph> or <ph id="3">&lt;languageKeyword&gt;|&lt;/languageKeyword&gt;</ph> operator.</target>
          </trans-unit>
          <trans-unit id="16" translate="yes" xml:space="preserve">
            <source>Recall that <ph id="1">&lt;codeInline&gt;searchMode&lt;/codeInline&gt;</ph> can be set to either <ph id="2">&lt;codeInline&gt;any&lt;/codeInline&gt;</ph> (default) or <ph id="3">&lt;codeInline&gt;all&lt;/codeInline&gt;</ph>.</source>
            <target state="new">Recall that <ph id="1">&lt;codeInline&gt;searchMode&lt;/codeInline&gt;</ph> can be set to either <ph id="2">&lt;codeInline&gt;any&lt;/codeInline&gt;</ph> (default) or <ph id="3">&lt;codeInline&gt;all&lt;/codeInline&gt;</ph>.</target>
          </trans-unit>
          <trans-unit id="17" translate="yes" xml:space="preserve">
            <source>If you use <ph id="1">&lt;codeInline&gt;any&lt;/codeInline&gt;</ph>, it will increase the recall of queries by including more results, and by default <ph id="2">&lt;languageKeyword&gt;-&lt;/languageKeyword&gt;</ph> will be interpreted as "OR NOT".</source>
            <target state="new">If you use <ph id="1">&lt;codeInline&gt;any&lt;/codeInline&gt;</ph>, it will increase the recall of queries by including more results, and by default <ph id="2">&lt;languageKeyword&gt;-&lt;/languageKeyword&gt;</ph> will be interpreted as "OR NOT".</target>
          </trans-unit>
          <trans-unit id="18" translate="yes" xml:space="preserve">
            <source>For example, "wifi –luxury" will match documents that either contain the term "wifi" or those that do not contain the term "luxury".</source>
            <target state="new">For example, "wifi –luxury" will match documents that either contain the term "wifi" or those that do not contain the term "luxury".</target>
          </trans-unit>
          <trans-unit id="19" translate="yes" xml:space="preserve">
            <source>If you use <ph id="1">&lt;codeInline&gt;all&lt;/codeInline&gt;</ph>, it will increase the precision of queries by including fewer results, and by default - will be interpreted as "AND NOT".</source>
            <target state="new">If you use <ph id="1">&lt;codeInline&gt;all&lt;/codeInline&gt;</ph>, it will increase the precision of queries by including fewer results, and by default - will be interpreted as "AND NOT".</target>
          </trans-unit>
          <trans-unit id="20" translate="yes" xml:space="preserve">
            <source>For example, "wifi –luxury" will match documents that contain the term "wifi" and do not contain the term "luxury".</source>
            <target state="new">For example, "wifi –luxury" will match documents that contain the term "wifi" and do not contain the term "luxury".</target>
          </trans-unit>
          <trans-unit id="21" translate="yes" xml:space="preserve">
            <source>This is arguably a more intuitive behavior for the <ph id="1">&lt;languageKeyword&gt;-&lt;/languageKeyword&gt;</ph> operator.</source>
            <target state="new">This is arguably a more intuitive behavior for the <ph id="1">&lt;languageKeyword&gt;-&lt;/languageKeyword&gt;</ph> operator.</target>
          </trans-unit>
          <trans-unit id="22" translate="yes" xml:space="preserve">
            <source>Therefore, you should consider using <ph id="1">&lt;languageKeyword&gt;searchMode=all&lt;/languageKeyword&gt;</ph> instead of <ph id="2">&lt;languageKeyword&gt;searchMode=any&lt;/languageKeyword&gt;</ph> if <bpt id="3">&lt;legacyItalic&gt;</bpt>both<ept id="3">&lt;/legacyItalic&gt;</ept> of the following are true:</source>
            <target state="new">Therefore, you should consider using <ph id="1">&lt;languageKeyword&gt;searchMode=all&lt;/languageKeyword&gt;</ph> instead of <ph id="2">&lt;languageKeyword&gt;searchMode=any&lt;/languageKeyword&gt;</ph> if <bpt id="3">&lt;legacyItalic&gt;</bpt>both<ept id="3">&lt;/legacyItalic&gt;</ept> of the following are true:</target>
          </trans-unit>
        </group>
        <group id="11">
          <trans-unit id="23" translate="yes" xml:space="preserve">
            <source>You want to optimize searches for precision instead of recall, and</source>
            <target state="new">You want to optimize searches for precision instead of recall, and</target>
          </trans-unit>
        </group>
        <group id="12">
          <trans-unit id="24" translate="yes" xml:space="preserve">
            <source>Your users frequently use the <ph id="1">&lt;languageKeyword&gt;-&lt;/languageKeyword&gt;</ph> operator in searches.</source>
            <target state="new">Your users frequently use the <ph id="1">&lt;languageKeyword&gt;-&lt;/languageKeyword&gt;</ph> operator in searches.</target>
          </trans-unit>
        </group>
        <group id="13">
          <trans-unit id="25" translate="yes" xml:space="preserve">
            <source>Suffix operator.</source>
            <target state="new">Suffix operator.</target>
          </trans-unit>
          <trans-unit id="26" translate="yes" xml:space="preserve">
            <source>For example, "lux*" will search for documents that have a term that starts with "lux", ignoring case.</source>
            <target state="new">For example, "lux*" will search for documents that have a term that starts with "lux", ignoring case.</target>
          </trans-unit>
        </group>
        <group id="14">
          <trans-unit id="27" translate="yes" xml:space="preserve">
            <source>Phrase search operator.</source>
            <target state="new">Phrase search operator.</target>
          </trans-unit>
          <trans-unit id="28" translate="yes" xml:space="preserve">
            <source>For example, while <bpt id="1">&lt;legacyItalic&gt;</bpt>Roach Motel<ept id="1">&lt;/legacyItalic&gt;</ept> (without quotes) would search for documents containing <bpt id="2">&lt;legacyItalic&gt;</bpt>Roach<ept id="2">&lt;/legacyItalic&gt;</ept> and/or <bpt id="3">&lt;legacyItalic&gt;</bpt>Motel<ept id="3">&lt;/legacyItalic&gt;</ept> anywhere in any order, "<bpt id="4">&lt;legacyItalic&gt;</bpt>Roach Motel<ept id="4">&lt;/legacyItalic&gt;</ept>" (with quotes) will only match documents that contains that whole phrase together and in that order (text analysis still applies).</source>
            <target state="new">For example, while <bpt id="1">&lt;legacyItalic&gt;</bpt>Roach Motel<ept id="1">&lt;/legacyItalic&gt;</ept> (without quotes) would search for documents containing <bpt id="2">&lt;legacyItalic&gt;</bpt>Roach<ept id="2">&lt;/legacyItalic&gt;</ept> and/or <bpt id="3">&lt;legacyItalic&gt;</bpt>Motel<ept id="3">&lt;/legacyItalic&gt;</ept> anywhere in any order, "<bpt id="4">&lt;legacyItalic&gt;</bpt>Roach Motel<ept id="4">&lt;/legacyItalic&gt;</ept>" (with quotes) will only match documents that contains that whole phrase together and in that order (text analysis still applies).</target>
          </trans-unit>
        </group>
        <group id="15">
          <trans-unit id="29" translate="yes" xml:space="preserve">
            <source>Precedence operator.</source>
            <target state="new">Precedence operator.</target>
          </trans-unit>
          <trans-unit id="30" translate="yes" xml:space="preserve">
            <source>For example, "motel+(wifi|luxury)" will search for documents containing the "motel" term and either "wifi" or "luxury" (or both).</source>
            <target state="new">For example, "motel+(wifi|luxury)" will search for documents containing the "motel" term and either "wifi" or "luxury" (or both).</target>
          </trans-unit>
        </group>
        <group id="16">
          <trans-unit id="31" translate="yes" xml:space="preserve">
            <source>Guidance for using search operators</source>
            <target state="new">Guidance for using search operators</target>
          </trans-unit>
        </group>
        <group id="17">
          <trans-unit id="32" translate="yes" xml:space="preserve">
            <source>In order to use the above symbols as actual part of the search text, they should be escaped by prefixing them with a backslash.</source>
            <target state="new">In order to use the above symbols as actual part of the search text, they should be escaped by prefixing them with a backslash.</target>
          </trans-unit>
          <trans-unit id="33" translate="yes" xml:space="preserve">
            <source>For example, "luxury\+hotel" will result in the term "luxury+hotel".</source>
            <target state="new">For example, "luxury\+hotel" will result in the term "luxury+hotel".</target>
          </trans-unit>
          <trans-unit id="34" translate="yes" xml:space="preserve">
            <source>In order to make things simple for the more typical cases, there are two exceptions to this rule where escaping is not needed:</source>
            <target state="new">In order to make things simple for the more typical cases, there are two exceptions to this rule where escaping is not needed:</target>
          </trans-unit>
        </group>
        <group id="18">
          <trans-unit id="35" translate="yes" xml:space="preserve">
            <source>Only needs to be escaped if it's the first character after whitespace, not if it's in the middle of a term.</source>
            <target state="new">Only needs to be escaped if it's the first character after whitespace, not if it's in the middle of a term.</target>
          </trans-unit>
          <trans-unit id="36" translate="yes" xml:space="preserve">
            <source>For example, "wi-fi" is a single term; GUIDs (such as "3352CDD0-EF30-4A2E-A512-3B30AF40F3FD") are treated as a single token.</source>
            <target state="new">For example, "wi-fi" is a single term; GUIDs (such as "3352CDD0-EF30-4A2E-A512-3B30AF40F3FD") are treated as a single token.</target>
          </trans-unit>
        </group>
        <group id="19">
          <trans-unit id="37" translate="yes" xml:space="preserve">
            <source>Only needs to be escaped if it's the last character before whitespace, not if it's in the middle of a term.</source>
            <target state="new">Only needs to be escaped if it's the last character before whitespace, not if it's in the middle of a term.</target>
          </trans-unit>
          <trans-unit id="38" translate="yes" xml:space="preserve">
            <source>For example, "wi*fi" is treated as a single token.</source>
            <target state="new">For example, "wi*fi" is treated as a single token.</target>
          </trans-unit>
        </group>
        <group id="20">
          <trans-unit id="39" translate="yes" xml:space="preserve">
            <source>One aspect to keep in mind is that while escaping will keep these tokens together, text analysis may end up splitting them later.</source>
            <target state="new">One aspect to keep in mind is that while escaping will keep these tokens together, text analysis may end up splitting them later.</target>
          </trans-unit>
          <trans-unit id="40" translate="yes" xml:space="preserve">
            <source>The specifics depend on the analysis mode.</source>
            <target state="new">The specifics depend on the analysis mode.</target>
          </trans-unit>
          <trans-unit id="41" translate="yes" xml:space="preserve">
            <source>See <ph id="1">&lt;link xlink:href="8f35915a-2bfa-4f23-80c3-e3f54e9e4543" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;Language support (Azure Search REST API)&lt;/link&gt;</ph> for details.</source>
            <target state="new">See <ph id="1">&lt;link xlink:href="8f35915a-2bfa-4f23-80c3-e3f54e9e4543" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;Language support (Azure Search REST API)&lt;/link&gt;</ph> for details.</target>
          </trans-unit>
        </group>
        <group id="21">
          <trans-unit id="42" translate="yes" xml:space="preserve">
            <source>For those familiar with Lucene, Azure Search uses Lucene's "Simple Query Parser" syntax with fuzzy/slop options disabled.</source>
            <target state="new">For those familiar with Lucene, Azure Search uses Lucene's "Simple Query Parser" syntax with fuzzy/slop options disabled.</target>
          </trans-unit>
        </group>
      </group>
    </body>
  </file>
</xliff>